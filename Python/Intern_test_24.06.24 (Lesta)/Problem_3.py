"""
Выбор оптимального алгоритма сортировки является непростой задачей: точность ее решения сильно зависит от того, что мы знаем и что можем 
предполагать о сортируемых данных. Аппелируя к сравнению сортировок (например, на Википедии https://en.wikipedia.org/wiki/Sorting_algorithm)
можно заметить, что время сортировки варьируется от линейной аппроксимации до квадратичной. Зачастую линейная временная сложность 
достигается за счет того, что о массиве данных заранее что-то известно - то есть можно специально подобрать наиболее подходящий алгоритм.
Например, подобное наблюдается при сортировке вставками: данный алгоритм особенно хорошо работает, если исходный массив уже почти 
отсортирован (временная сложность O(n)).

Проще говоря, надежнее сразу использовать алгоритм, который чаще и стабильнее сортирует хорошо, чем тот, что сортирует отлично в 
исключительных случаях. Поэтому во многих практических реализациях чаще выбирают алгоритмы, средняя временная сложность которых порядка 
O(n log n). Из подобных алгоритмов можно привести в пример Heapsort (сортировка кучей), Merge sort (сортировка слиянием) и относительно новую 
Timsort. Для данной задачи яостановила свой выбор на Timsort, потому что эта сортировка отлично показывает себя на практически любых данных 
(что соответствует условию задачи про произвольность размера и случайный порядок чисел). Ее средняя временная сложность действительно порядка 
O(n log n), но при этом при удачном стечении обстоятельств Timsort может работать еще быстрее и иметь временную сложность O(n). Кроме того, 
этот алгоритм является устойчивым. Основной недостаток Timsort это объем дополнительной памяти, который он требует для реализации: он составляет 
порядка 30-40% от исходного объема памяти, нужного для хранения исходного массива. И все же Timsort выгоден настолько, что применяется даже в 
качестве стандартного алгоритма сортировки в Python: именно он используется в sorted(list) и list.sort().

Причина, по которым Timsort так хорошо работает, заключается в нескольких особенностях его построения. Во-первых, он с самого начала
разрабатывался как алгоритм, который будет успешно применяться на реалистичных наборах данных, в которых нередко встречаются частичные
упорядочения (упорядоченные подмассивы). Timsort является гибридным алгоритмом, созданным на идее совместного применения алгоритма вставками,
который хорошо показывает себя на таких данных, в которых есть упорядоченные подмассивы, и алгоритме слиянием, который, в свою очередь,
хорош для различных вариантов работы с памятью (подкачка, кэширование, внешняя память) и больших массивах. Оба алгоритма устойчивы, поэтому,
как я говорила выше, Timsort тоже устойчив. Итак, идея заключается в разделении исходного массива на подмассивы, которые уже частично упорядочены. 
Такие разделения называются ранами (run). Было экспериментально найдено, что минимальная длина рана (minrun) от 32 до 64 элементов является 
оптимальной для наибольшей эффективности алгоритма: если ранов слишком много, то кусочки слишком маленькие и слияния становятся менее эффективным, 
а при большом minrun сортировка вставками будет работать слишком долго. Поэтому нужно брать длины ранов не очень большими и не очень маленькими.
Было показано, что в идеале количество слияний должно быть степенью двойки или немного меньше (тогда неэффективных слияний не слишком много).
Итак, мы поделили наш массив на подмассивы с частичным упорядочением, на которых отлично работает сортировка вставками. Когда мы отсортировали
такие подмассивы, происходит "фаза" слияния, когда мы объединяем массивы по два и вновь используем сортировку вставками. Процесс продолжается
до тех пор, пока массив не будет отсортирован.

Настоящая реализация Timsort создана на языке C и отличается большой сложностью относительно многих других алгоритмов. К сожалению, мне не
удалось разобраться во всех тонкостях, но ниже я постаралась привести базовую реализацию этого алгоритма, которая иллюстрирует основные 
принципы его работы.
"""

MIN_RUN = 32

def insertion_sort(array, left, right):
    for i in range(left + 1, right + 1):
        current_element = array[i]
        j = i - 1
        while j >= left and array[j] > current_element:
            array[j + 1] = array[j]
            j -= 1
        array[j + 1] = current_element

def merge_sort(array, left, mid, right):
    len_left, len_right = mid - left + 1, right - mid
    left_part, right_part = array[left:left + len_left], array[mid + 1:mid + 1 + len_right]
    i = j = 0
    k = left
    while i < len_left and j < len_right:
        if left_part[i] <= right_part[j]:
            array[k] = left_part[i]
            i += 1
        else:
            array[k] = right_part[j]
            j += 1
        k += 1
    while i < len_left:
        array[k] = left_part[i]
        i += 1
        k += 1
    while j < len_right:
        array[k] = right_part[j]
        j += 1
        k += 1

def timsort(array):
    n = len(array)
    for start in range(0, n, MIN_RUN):
        end = min(start + MIN_RUN - 1, n - 1)
        insertion_sort(array, start, end)
    run_size = MIN_RUN
    while run_size < n:
        for left in range(0, n, 2 * run_size):
            mid = min(n - 1, left + run_size - 1)
            right = min(n - 1, mid + run_size)

            if mid < right:
                merge(array, left, mid, right)
        run_size *= 2

"""
Использование оптимальной реализации алгоритма Timsort на Python с помощью стандартных методов:
"""

arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]
sorted_arr = sorted(arr)
print(sorted_arr)

"""
Также хочется еще раз упомянуть Heapsort и Merge sort из-за того, что у каждого из них есть существенное преимущество, 
которое может оказаться полезным в конкретной задаче. 

Хотя Heapsort имеет временную сложность не лучше O(n log n) (что все еще довольно хорошо), этот алгоритм  не нуждается 
в дополнительной памяти, что может оказаться полезным при ее ограничении. Однако этот алгоритм неустойчив (что может 
быть неудобно при тестировании), его нельзя распараллелить и если данные почти отсортированы, то это свойство почти не 
ускорит время работы алгоритма.

Merge sort в практических применениях зачастую предпочтительнее Heapsort даже с точки зрения памяти: несмотря на то, 
что этот алгоритм требует выделения O(n) дополнительной памяти, он отлично показывает себя при использовании кэшированной 
памяти. Обычно доступ к ней производится быстрее, чем к обычной памяти. Также этот метод устойчив, его удобно применять
"по частям" (соответственно проще иметь дело с большими данными) и распараллеливать (что улучшает его временную сложность
вплоть до O(log n)).

Ниже я привожу реализации алгоритмов Heapsort и Merge sort.
_____________________

Heapsort: алгоритм основан на построении двоичного дерева, корневым элементом которого становится array[0]. Индексы детей 
всегда равны 2i + 1 и 2i + 2. Рассмотрим последний (самый правый) родительский узел и сравним с детьми этого узла. Если
значение какого-то из детей больше значения родительского элемента - меняем их местами (если оба больше - меняем с наибольшим).
Продолжаем так делать справа налево, снизу вверх, из-за чего самое большое число в массиве двигается к корню. Когда итерация 
окончена, необходимо поменять первый и последний элементы и начать сначала, исключив из рассмотрения полученный наибольший
элемент массива.
"""

def heapify(array, length, root):
    max = root
    left_child = 2 * root + 1
    right_child = 2 * root + 2
    if left_child < length and arr[left_child] > array[max]:
        max = left_child
    if right_child < length and array[right_child] > array[max]:
        max = right_child
    if max != root:
        array[root], array[max] = array[max], array[root]
        heapify(array, length, max)

def heapsort(array):
    length = len(array)
    for i in range(length // 2 - 1, -1, -1):
        heapify(array, length, i)
    for i in range(length - 1, 0, -1):
        array[i], array[0] = array[0], array[i]
        heapify(array, i, 0)
    return array
    
"""
Merge sort: делим массив на две примерно одинаковые части, рекурсивно сортируем каждую из них, а затем объединяем.
Прим.: во время объединения мы сравниваем элементы в объединяемых массивах и кладем в результирующий массив сперва тот, который меньше.
"""

def merge_sort(array):
    if len(array) <= 1:
        return array
    left_half = merge_sort(array[:len(array) // 2])
    right_half = merge_sort(array[len(array) // 2:])
    i = j = k = 0
    result = [0] * len(array)
    while i < len(left_half) and j < len(right_half):
        if left_half[i] < right_half[j]:
            result[k] = left_half[i]
            i += 1
        else:
            result[k] = right_half[j]
            j += 1
        k += 1
    while i < len(left_half):
        result[k] = left_half[i]
        i += 1
        k += 1
    while j < len(right_half):
        result[k] = right_half[j]
        j += 1
        k += 1
    for i in range(len(array)):
        array[i] = result[i]
    return array
