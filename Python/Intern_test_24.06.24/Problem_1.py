"""
Реализация через деление isEven и обе реализации через побитовые операции isEvenBitwise1 и isEvenBitwise2 имеют 
временную сложность O(1) для небольших чисел, но если числа становятся больше, чем 2^30, то Python хранит их как
несколько слов. Это приводит к увеличению временной сложности реализаций isEven и isEvenBitwise2 пропорционально 
количеству слов в числе и, следовательно, пропорционально O(n), где n - количество слов в числе.

Первый вариант с побитовыми операциями isEvenBitwise1 является наиболее быстрым, так как операция & оперирует на-
прямую с байтами числа и не зависит от количества слов: даже в случае очень большого числа value операция побито-
вого умножения производится только на слове, содержащем младший байт, и его временная сложность всегда O(1). Опе-
рация же сравнения с нулем хорошо оптимизирована, и, кроме того, во всех реализациях мы делаем как минимум одно 
сравнение.

Второй побитовый вариант isEvenBitwise2 все еще быстрее, чем исходный isEven, но медленнее первого, так как ис-
пользует две побитовые операции и одно сравнение. Кроме того, временная сложность операции сдвига тоже зависит 
от количества слов в числе и возрастает линейный образом как O(n).

Однако реализации, использующие побитовые операции, гораздо менее понятны с интуитивной точки зрения (мы просто
в меньшей степени привыкли работать с ними) и требуют общего понимания того, как хранятся числа в памяти компью-
тера. Это также может приводить к ошибкам в коде.

Я также решила добавить вариант с рекурсией, потому что он кажется мне интересным с точки зрения реализации и
общего понимания, потому что алгоритмы с рекурсивным подходом все же используются в задачах с обходом деревьяв
и графов, при некоторых алгоритмах сортировки (быстрая сортировка и сортировка слиянием) и в динамическом про-
граммировании.

Вариант с рекурсией isEvenRecursion самый сложный с точки зрения времени: его временная сложность даже для не-
больших чисел линейно зависит от значения числа как O(N) (N/2 вызовов самой себя), и здесь также нужно учиты-
вать время, которое затрачивается на многократный вызов функции. Кроме того, рекурсия может легко переполнить
стек, и потому ее использование быстро становится невыгодным даже с точки зрения памяти.

TL;DR: временная сложность первого метода isEvenBitwise1 пропорциональна O(1) независимо от количества слов в
числе, и поэтому он самый быстрый, но менее интуитивно понятный, чем исходная реализация через деление. В то же 
время исходная реализация интуитивно понятна, но при больших N > 2^30 (обусловлено самим Python) начинает зави-
сеть от количества слов линейно как O(n).
"""

def isEvenBitwise1(value):
    return (value & 1) == 0

def isEvenBitwise2(value):
    return value == (value >> 1 << 1)

def isEvenRecursion(value):
    if (value < 2):
        return value == 0
    else:
        return isEven(value - 2)
        